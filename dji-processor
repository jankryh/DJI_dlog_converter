#!/usr/bin/env bash
# DJI D-Log Video Processor
# Applies LUT to DJI D-Log video files using FFmpeg
# Optimized for performance and simplicity

set -euo pipefail

# Configuration - easily customizable
readonly LUT_FILE="${LUT_FILE:-./luts/Avata2.cube}"
readonly QUALITY="${QUALITY:-professional}"  # draft, standard, high, professional
readonly OUTPUT_SUFFIX="${OUTPUT_SUFFIX:-_processed}"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

# Logging functions
log_info() { echo -e "${BLUE}ℹ️  $1${NC}"; }
log_success() { echo -e "${GREEN}✅ $1${NC}"; }
log_warning() { echo -e "${YELLOW}⚠️  $1${NC}"; }
log_error() { echo -e "${RED}❌ $1${NC}" >&2; }

# Show usage
show_usage() {
    cat << EOF
DJI D-Log Video Processor

USAGE:
    $0 <input_file> [output_file] [options]

ARGUMENTS:
    input_file     Path to input MP4 file
    output_file    Path to output file (optional, auto-generated if not provided)

OPTIONS:
    --lut FILE     LUT file path (default: $LUT_FILE)
    --quality SET  Quality preset: draft, standard, high, professional (default: $QUALITY)
    --help         Show this help message

EXAMPLES:
    $0 video.mp4
    $0 video.mp4 processed_video.mp4
    $0 video.mp4 --lut ./custom.cube --quality high

ENVIRONMENT VARIABLES:
    LUT_FILE       Default LUT file path
    QUALITY        Default quality preset
    OUTPUT_SUFFIX  Suffix for auto-generated output files (default: _processed)
EOF
}

# Check dependencies
check_dependencies() {
    local missing=()
    
    if ! command -v ffmpeg >/dev/null 2>&1; then
        missing+=("ffmpeg")
    fi
    
    if ! command -v ffprobe >/dev/null 2>&1; then
        missing+=("ffprobe")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing[*]}"
        log_info "Install with: brew install ffmpeg (macOS) or apt-get install ffmpeg (Linux)"
        exit 1
    fi
}

# Get quality settings optimized for different encoders
get_quality_settings() {
    local quality="$1"
    local encoder="$2"
    
    # Detect hardware acceleration
    if [[ "$encoder" == "h264_videotoolbox" ]]; then
        # VideoToolbox (macOS hardware acceleration)
        case "$quality" in
            draft) echo "-q:v 80 -realtime 1" ;;
            standard) echo "-q:v 65" ;;
            high) echo "-q:v 50" ;;
            professional) echo "-q:v 35" ;;
            *) echo "-q:v 65" ;;
        esac
    else
        # Software encoding (x264)
        case "$quality" in
            draft) echo "-crf 28 -preset ultrafast" ;;
            standard) echo "-crf 23 -preset medium" ;;
            high) echo "-crf 20 -preset slow" ;;
            professional) echo "-crf 18 -preset veryslow" ;;
            *) echo "-crf 23 -preset medium" ;;
        esac
    fi
}

# Detect best available encoder
detect_encoder() {
    # Check for hardware acceleration first
    if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_videotoolbox"; then
        echo "h264_videotoolbox"
    elif ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_vaapi"; then
        echo "h264_vaapi"
    elif ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_nvenc"; then
        echo "h264_nvenc"
    else
        echo "libx264"
    fi
}

# Get video duration for progress tracking
get_video_duration() {
    local input_file="$1"
    ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$input_file" 2>/dev/null | head -n1
}

# Show progress bar
show_progress() {
    local current_time="$1"
    local duration="$2"
    local filename="$3"
    local bar_length=30
    
    local progress=$((current_time * 100 / duration))
    [[ $progress -gt 100 ]] && progress=100
    
    local filled=$((bar_length * progress / 100))
    local empty=$((bar_length - filled))
    
    local bar=""
    for ((i=0; i<filled; i++)); do bar+="█"; done
    for ((i=filled; i<bar_length; i++)); do bar+="░"; done
    
    printf "\r🎬 %s [%s] %d%%" "$filename" "$bar" "$progress"
}

# Process video file
process_video() {
    local input_file="$1"
    local output_file="$2"
    local lut_file="$3"
    local quality="$4"
    
    # Validate input file
    if [[ ! -f "$input_file" ]]; then
        log_error "Input file not found: $input_file"
        return 1
    fi
    
    # Get video duration
    local duration
    duration=$(get_video_duration "$input_file")
    if [[ -z "$duration" ]]; then
        log_error "Cannot read video duration from: $input_file"
        return 1
    fi
    
    # Convert duration to integer for progress calculation
    local duration_int
    printf -v duration_int "%.0f" "$duration"
    
    # Detect best encoder
    local encoder
    encoder=$(detect_encoder)
    log_info "Using encoder: $encoder"
    
    # Get quality settings
    local quality_args
    quality_args=$(get_quality_settings "$quality" "$encoder")
    
    # Build FFmpeg command with optimized settings
    local ffmpeg_cmd=(
        ffmpeg
        -hide_banner
        -loglevel error
        -progress pipe:1
        -nostdin
        -i "$input_file"
        -vf "lut3d='$lut_file'"
        -c:v "$encoder"
        $quality_args
        -c:a copy
        -movflags +faststart
        -y "$output_file"
    )
    
    # Add hardware acceleration if available
    case "$encoder" in
        h264_videotoolbox)
            ffmpeg_cmd=(
                ffmpeg
                -hide_banner
                -loglevel error
                -progress pipe:1
                -nostdin
                -hwaccel videotoolbox
                -i "$input_file"
                -vf "lut3d='$lut_file'"
                -c:v "$encoder"
                $quality_args
                -c:a copy
                -movflags +faststart
                -y "$output_file"
            )
            ;;
        h264_vaapi)
            ffmpeg_cmd=(
                ffmpeg
                -hide_banner
                -loglevel error
                -progress pipe:1
                -nostdin
                -hwaccel vaapi
                -i "$input_file"
                -vf "lut3d='$lut_file'"
                -c:v "$encoder"
                $quality_args
                -c:a copy
                -movflags +faststart
                -y "$output_file"
            )
            ;;
    esac
    
    log_info "Processing: $(basename "$input_file") → $(basename "$output_file")"
    log_info "Duration: ${duration_int}s | Quality: $quality"
    
    # Process with progress tracking
    local start_time
    start_time=$(date +%s)
    
    if "${ffmpeg_cmd[@]}" | while IFS= read -r line; do
        local current_time=""
        
        # Parse time from ffmpeg progress output
        if [[ "$line" =~ out_time_us=([0-9]+) ]]; then
            current_time=$((${BASH_REMATCH[1]} / 1000000))
        elif [[ "$line" =~ time=([0-9]+):([0-9]+):([0-9]+)\.([0-9]+) ]]; then
            local h=$((10#${BASH_REMATCH[1]}))
            local m=$((10#${BASH_REMATCH[2]}))
            local s=$((10#${BASH_REMATCH[3]}))
            current_time=$((h * 3600 + m * 60 + s))
        elif [[ "$line" =~ time=([0-9]+)\.([0-9]+) ]]; then
            current_time=${BASH_REMATCH[1]}
        fi
        
        # Update progress bar
        if [[ -n "$current_time" && $current_time -gt 0 ]]; then
            show_progress "$current_time" "$duration_int" "$(basename "$input_file")"
        fi
    done; then
        echo ""  # New line after progress bar
        
        # Calculate processing time
        local end_time
        end_time=$(date +%s)
        local processing_time=$((end_time - start_time))
        local proc_min=$((processing_time / 60))
        local proc_sec=$((processing_time % 60))
        
        # Show file size
        local size
        size=$(du -h "$output_file" | cut -f1)
        
        log_success "Completed: $(basename "$output_file")"
        log_info "Size: $size | Time: $(printf "%02d:%02d" "$proc_min" "$proc_sec")"
        return 0
    else
        echo ""  # New line after progress bar
        log_error "Failed to process: $(basename "$input_file")"
        return 1
    fi
}

# Main function
main() {
    local input_file=""
    local output_file=""
    local lut_file="$LUT_FILE"
    local quality="$QUALITY"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                show_usage
                exit 0
                ;;
            --lut)
                lut_file="$2"
                shift 2
                ;;
            --quality)
                quality="$2"
                shift 2
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                if [[ -z "$input_file" ]]; then
                    input_file="$1"
                elif [[ -z "$output_file" ]]; then
                    output_file="$1"
                else
                    log_error "Too many arguments"
                    show_usage
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$input_file" ]]; then
        log_error "Input file is required"
        show_usage
        exit 1
    fi
    
    # Generate output filename if not provided
    if [[ -z "$output_file" ]]; then
        local dir
        local name
        local ext
        dir=$(dirname "$input_file")
        name=$(basename "$input_file" .mp4)
        ext=".mp4"
        output_file="$dir/${name}${OUTPUT_SUFFIX}${ext}"
    fi
    
    # Validate LUT file
    if [[ ! -f "$lut_file" ]]; then
        log_error "LUT file not found: $lut_file"
        log_info "💡 Download a LUT file for your DJI drone or specify with --lut"
        exit 1
    fi
    
    # Validate quality preset
    case "$quality" in
        draft|standard|high|professional) ;;
        *)
            log_error "Invalid quality preset: $quality"
            log_info "Valid options: draft, standard, high, professional"
            exit 1
            ;;
    esac
    
    # Check dependencies
    check_dependencies
    
    # Process the video
    if process_video "$input_file" "$output_file" "$lut_file" "$quality"; then
        log_success "Video processing completed successfully!"
        log_info "Output: $output_file"
        exit 0
    else
        log_error "Video processing failed"
        exit 1
    fi
}

# Run main function with all arguments
main "$@"
