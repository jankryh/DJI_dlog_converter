#!/usr/bin/env bash
# DJI D-Log Video Processor
# Applies LUT to DJI D-Log video files using FFmpeg
# Optimized for performance and simplicity

set -euo pipefail

# Configuration - easily customizable
readonly LUT_FILE="${LUT_FILE:-./luts/Avata2.cube}"
readonly QUALITY="${QUALITY:-professional}"  # draft, standard, high, professional
readonly OUTPUT_SUFFIX="${OUTPUT_SUFFIX:-_processed}"
readonly CODEC="${CODEC:-h264}"  # h264, h265

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

# Logging functions
log_info() { echo -e "${BLUE}â„¹ï¸  $1${NC}"; }
log_success() { echo -e "${GREEN}âœ… $1${NC}"; }
log_warning() { echo -e "${YELLOW}âš ï¸  $1${NC}"; }
log_error() { echo -e "${RED}âŒ $1${NC}" >&2; }

# Show usage
show_usage() {
    cat << EOF
DJI D-Log Video Processor

USAGE:
    $0 <input_file> [output_file] [options]

ARGUMENTS:
    input_file     Path to input MP4 file or directory
    output_file    Path to output file or directory (optional)

OPTIONS:
    --lut FILE     LUT file path (default: $LUT_FILE)
    --quality SET  Quality preset: draft, standard, high, professional (default: $QUALITY)
    --codec TYPE   Video codec: h264, h265 (default: $CODEC)
    --dry-run      Print command without executing
    --help         Show this help message

EXAMPLES:
    $0 video.mp4
    $0 video.mp4 processed_video.mp4
    $0 video.mp4 --lut ./custom.cube --quality high

ENVIRONMENT VARIABLES:
    LUT_FILE       Default LUT file path
    QUALITY        Default quality preset
    CODEC          Default video codec (h264, h265)
    OUTPUT_SUFFIX  Suffix for auto-generated output files (default: _processed)
EOF
}

# Check dependencies
check_dependencies() {
    local missing=()
    
    if ! command -v ffmpeg >/dev/null 2>&1; then
        missing+=("ffmpeg")
    fi
    
    if ! command -v ffprobe >/dev/null 2>&1; then
        missing+=("ffprobe")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing[*]}"
        log_info "Install with: brew install ffmpeg (macOS) or apt-get install ffmpeg (Linux)"
        exit 1
    fi
}

# Get quality settings optimized for different encoders
get_quality_settings() {
    local quality="$1"
    local encoder="$2"
    
    # Detect hardware acceleration
    if [[ "$encoder" == "h264_videotoolbox" || "$encoder" == "hevc_videotoolbox" ]]; then
        # VideoToolbox (macOS hardware acceleration)
        case "$quality" in
            draft) echo "-q:v 80 -realtime 1" ;;
            standard) echo "-q:v 65" ;;
            high) echo "-q:v 50" ;;
            professional) echo "-q:v 35" ;;
            *) echo "-q:v 65" ;;
        esac
    elif [[ "$encoder" == "libx265" ]]; then
        # Software encoding (x265) - adjusted for HEVC efficiency
        case "$quality" in
            draft) echo "-crf 32 -preset ultrafast" ;;
            standard) echo "-crf 28 -preset medium" ;;
            high) echo "-crf 24 -preset slow" ;;
            professional) echo "-crf 20 -preset veryslow" ;;
            *) echo "-crf 28 -preset medium" ;;
        esac
    else
        # Software encoding (x264)
        case "$quality" in
            draft) echo "-crf 28 -preset ultrafast" ;;
            standard) echo "-crf 23 -preset medium" ;;
            high) echo "-crf 20 -preset slow" ;;
            professional) echo "-crf 18 -preset veryslow" ;;
            *) echo "-crf 23 -preset medium" ;;
        esac
    fi
}

# Detect best available encoder
detect_encoder() {
    local codec="$1"
    
    if [[ "$codec" == "h265" || "$codec" == "hevc" ]]; then
        # HEVC / H.265
        if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "hevc_videotoolbox"; then
            echo "hevc_videotoolbox"
        elif ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "hevc_vaapi"; then
            echo "hevc_vaapi"
        elif ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "hevc_nvenc"; then
            echo "hevc_nvenc"
        else
            echo "libx265"
        fi
    else
        # AVC / H.264 (Default)
        if ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_videotoolbox"; then
            echo "h264_videotoolbox"
        elif ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_vaapi"; then
            echo "h264_vaapi"
        elif ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "h264_nvenc"; then
            echo "h264_nvenc"
        else
            echo "libx264"
        fi
    fi
}

# Get video duration for progress tracking
get_video_duration() {
    local input_file="$1"
    ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$input_file" 2>/dev/null | head -n1
}

# Show progress bar
show_progress() {
    local current_time="$1"
    local duration="$2"
    local filename="$3"
    local bar_length=30
    
    local progress=$((current_time * 100 / duration))
    [[ $progress -gt 100 ]] && progress=100
    
    local filled=$((bar_length * progress / 100))
    local empty=$((bar_length - filled))
    
    local bar=""
    for ((i=0; i<filled; i++)); do bar+="â–ˆ"; done
    for ((i=filled; i<bar_length; i++)); do bar+="â–‘"; done
    
    printf "\rðŸŽ¬ %s [%s] %d%%" "$filename" "$bar" "$progress"
}

# Process video file
process_video() {
    local input_file="$1"
    local output_file="$2"
    local lut_file="$3"
    local quality="$4"
    local codec="$5"
    local dry_run="$6"
    
    # Validate input file
    if [[ ! -f "$input_file" ]]; then
        log_error "Input file not found: $input_file"
        return 1
    fi
    
    # Get video duration
    local duration=""
    local duration_int=0
    
    if [[ "$dry_run" != "true" ]]; then
        duration=$(get_video_duration "$input_file")
        if [[ -z "$duration" ]]; then
            log_error "Cannot read video duration from: $input_file"
            return 1
        fi
        printf -v duration_int "%.0f" "$duration"
    fi
    
    # Detect best encoder
    local encoder
    encoder=$(detect_encoder "$codec")
    
    if [[ "$dry_run" != "true" ]]; then
        log_info "Using encoder: $encoder"
    fi
    
    # Get quality settings
    local quality_args
    quality_args=$(get_quality_settings "$quality" "$encoder")
    
    # Build FFmpeg command with optimized settings
    local ffmpeg_cmd=(
        ffmpeg
        -hide_banner
        -loglevel error
        -progress pipe:1
        -nostdin
        -i "$input_file"
        -vf "lut3d='$lut_file'"
        -c:v "$encoder"
        $quality_args
        -c:a copy
        -map_metadata 0
        -movflags +faststart+use_metadata_tags
        -y "$output_file"
    )
    
    # Add hardware acceleration if available
    case "$encoder" in
        h264_videotoolbox|hevc_videotoolbox)
            ffmpeg_cmd=(
                ffmpeg
                -hide_banner
                -loglevel error
                -progress pipe:1
                -nostdin
                -hwaccel videotoolbox
                -i "$input_file"
                -vf "lut3d='$lut_file'"
                -c:v "$encoder"
                $quality_args
                -c:a copy
                -map_metadata 0
                -movflags +faststart+use_metadata_tags
                -y "$output_file"
            )
            ;;
        h264_vaapi|hevc_vaapi)
            ffmpeg_cmd=(
                ffmpeg
                -hide_banner
                -loglevel error
                -progress pipe:1
                -nostdin
                -hwaccel vaapi
                -i "$input_file"
                -vf "lut3d='$lut_file'"
                -c:v "$encoder"
                $quality_args
                -c:a copy
                -map_metadata 0
                -movflags +faststart+use_metadata_tags
                -y "$output_file"
            )
            ;;
    esac
    
    # Dry run check
    if [[ "$dry_run" == "true" ]]; then
        echo "${ffmpeg_cmd[@]}"
        return 0
    fi
    
    log_info "Processing: $(basename "$input_file") â†’ $(basename "$output_file")"
    log_info "Duration: ${duration_int}s | Quality: $quality"
    
    # Process with progress tracking
    local start_time
    start_time=$(date +%s)
    
    if "${ffmpeg_cmd[@]}" | while IFS= read -r line; do
        local current_time=""
        
        # Parse time from ffmpeg progress output
        if [[ "$line" =~ out_time_us=([0-9]+) ]]; then
            current_time=$((${BASH_REMATCH[1]} / 1000000))
        elif [[ "$line" =~ time=([0-9]+):([0-9]+):([0-9]+)\.([0-9]+) ]]; then
            local h=$((10#${BASH_REMATCH[1]}))
            local m=$((10#${BASH_REMATCH[2]}))
            local s=$((10#${BASH_REMATCH[3]}))
            current_time=$((h * 3600 + m * 60 + s))
        elif [[ "$line" =~ time=([0-9]+)\.([0-9]+) ]]; then
            current_time=${BASH_REMATCH[1]}
        fi
        
        # Update progress bar
        if [[ -n "$current_time" && $current_time -gt 0 ]]; then
            show_progress "$current_time" "$duration_int" "$(basename "$input_file")"
        fi
    done; then
        echo ""  # New line after progress bar
        
        # Calculate processing time
        local end_time
        end_time=$(date +%s)
        local processing_time=$((end_time - start_time))
        local proc_min=$((processing_time / 60))
        local proc_sec=$((processing_time % 60))
        
        # Show file size
        local size
        size=$(du -h "$output_file" | cut -f1)
        
        log_success "Completed: $(basename "$output_file")"
        log_info "Size: $size | Time: $(printf "%02d:%02d" "$proc_min" "$proc_sec")"
        return 0
    else
        echo ""  # New line after progress bar
        log_error "Failed to process: $(basename "$input_file")"
        return 1
    fi
}

# Main function
main() {
    local input_file=""
    local output_file=""
    local lut_file="$LUT_FILE"
    local quality="$QUALITY"
    local codec="$CODEC"
    local dry_run="false"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                show_usage
                exit 0
                ;;
            --lut)
                lut_file="$2"
                shift 2
                ;;
            --quality)
                quality="$2"
                shift 2
                ;;
            --codec)
                codec="$2"
                shift 2
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                if [[ -z "$input_file" ]]; then
                    input_file="$1"
                elif [[ -z "$output_file" ]]; then
                    output_file="$1"
                else
                    log_error "Too many arguments"
                    show_usage
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$input_file" ]]; then
        log_error "Input file is required"
        show_usage
        exit 1
    fi
    
    # Check if input is a directory for batch processing
    if [[ -d "$input_file" ]]; then
        local input_dir="$input_file"
        local output_dir="$output_file"
        
        log_info "ðŸ“‚ Batch processing directory: $input_dir"
        
        # Create output directory if specified
        if [[ -n "$output_dir" ]]; then
            if [[ ! -d "$output_dir" ]]; then
                if [[ "$dry_run" != "true" ]]; then
                    mkdir -p "$output_dir"
                    log_info "Created output directory: $output_dir"
                else
                    log_info "Would create output directory: $output_dir"
                fi
            fi
        fi
        
        # Find video files
        local found_files=0
        # Use nullglob to handle empty directories gracefully
        shopt -s nullglob
        for file in "$input_dir"/*.mp4 "$input_dir"/*.MOV "$input_dir"/*.mov; do
            [[ -f "$file" ]] || continue
            found_files=1
            
            local filename
            filename=$(basename "$file")
            local name="${filename%.*}"
            local ext="${filename##*.}"
            local current_output=""
            
            if [[ -n "$output_dir" ]]; then
                current_output="$output_dir/${name}${OUTPUT_SUFFIX}.${ext}"
            else
                current_output="$input_dir/${name}${OUTPUT_SUFFIX}.${ext}"
            fi
            
            process_video "$file" "$current_output" "$lut_file" "$quality" "$codec" "$dry_run"
        done
        shopt -u nullglob
        
        if [[ $found_files -eq 0 ]]; then
            log_warning "No video files found in $input_dir"
        else
             if [[ "$dry_run" != "true" ]]; then
                log_success "Batch processing completed!"
             fi
        fi
        
        exit 0
    fi

    # Generate output filename if not provided
    if [[ -z "$output_file" ]]; then
        local dir
        local name
        local ext
        dir=$(dirname "$input_file")
        name=$(basename "$input_file" .mp4)
        ext=".mp4"
        output_file="$dir/${name}${OUTPUT_SUFFIX}${ext}"
    fi
    
    # Validate LUT file
    if [[ ! -f "$lut_file" ]]; then
        log_error "LUT file not found: $lut_file"
        log_info "ðŸ’¡ Download a LUT file for your DJI drone or specify with --lut"
        exit 1
    fi
    
    # Validate quality preset
    case "$quality" in
        draft|standard|high|professional) ;;
        *)
            log_error "Invalid quality preset: $quality"
            log_info "Valid options: draft, standard, high, professional"
            exit 1
            ;;
    esac
    
    # Check dependencies
    check_dependencies
    
    # Process the video
    if process_video "$input_file" "$output_file" "$lut_file" "$quality" "$codec" "$dry_run"; then
        if [[ "$dry_run" != "true" ]]; then
            log_success "Video processing completed successfully!"
            log_info "Output: $output_file"
        fi
        exit 0
    else
        log_error "Video processing failed"
        exit 1
    fi
}

# Run main function with all arguments
main "$@"
